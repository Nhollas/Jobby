(function (e, r) { if (typeof module != "undefined") { module.exports = r() } else if (typeof define === "function" && define.amd) { define([], r) } else { e._hyperscript = r() } })(typeof self !== "undefined" ? self : this, function () { "use strict"; function j(e, r) { for (var t in r) { if (r.hasOwnProperty(t)) { e[t] = r[t] } } return e } function H(e, r) { var t = e[r]; if (t) { return t } else { var n = {}; e[r] = n; return n } } function r(e) { try { return JSON.parse(e) } catch (e) { t(e); return null } } function t(e) { if (console.error) { console.error(e) } else if (console.log) { console.log("ERROR: ", e) } } function u(e, r) { return new (e.bind.apply(e, [e].concat(r))) } var G = typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : this; var B = function () { var N = { "+": "PLUS", "-": "MINUS", "*": "MULTIPLY", "/": "DIVIDE", ".": "PERIOD", "..": "ELLIPSIS", "\\": "BACKSLASH", ":": "COLON", "%": "PERCENT", "|": "PIPE", "!": "EXCLAMATION", "?": "QUESTION", "#": "POUND", "&": "AMPERSAND", $: "DOLLAR", ";": "SEMI", ",": "COMMA", "(": "L_PAREN", ")": "R_PAREN", "<": "L_ANG", ">": "R_ANG", "<=": "LTE_ANG", ">=": "GTE_ANG", "==": "EQ", "===": "EQQ", "!=": "NEQ", "!==": "NEQQ", "{": "L_BRACE", "}": "R_BRACE", "[": "L_BRACKET", "]": "R_BRACKET", "=": "EQUALS" }; function I(e) { return L(e) || C(e) || e === "-" || e === "_" || e === ":" } function R(e) { return L(e) || C(e) || e === "-" || e === "_" || e === ":" } function O(e) { return e === " " || e === "\t" || A(e) } function S(e) { return "[Line: " + e.line + ", Column: " + e.col + "]" } function A(e) { return e === "\r" || e === "\n" } function C(e) { return e >= "0" && e <= "9" } function L(e) { return e >= "a" && e <= "z" || e >= "A" && e <= "Z" } function F(e) { return e === "_" || e === "$" } function P(e) { return e === "`" || e === "^" } function M(i, o, e) { u(); var r = null; function u() { while (y(0, true).type === "WHITESPACE") { o.push(i.shift()) } } function s(e, r) { U.raiseParseError(e, r) } function t(e) { var r = l(e); if (r) { return r } else { s(this, "Expected '" + e + "' but found '" + k().value + "'") } } function n(e, r, t) { for (var n = 0; n < arguments.length; n++) { var a = arguments[n]; var i = l(a); if (i) { return i } } } function a(e, r, t) { for (var n = 0; n < arguments.length; n++) { var a = arguments[n]; var i = m(a); if (i) { return i } } } function l(e) { if (k() && k().op && k().value === e) { return v() } } function f(e, r, t, n) { var a = c(e, r, t, n); if (a) { return a } else { s(this, "Expected one of " + JSON.stringify([e, r, t])) } } function c(e, r, t, n) { if (k() && k().type && [e, r, t, n].indexOf(k().type) >= 0) { return v() } } function p(e, r) { var t = m(e, r); if (t) { return t } else { s(this, "Expected '" + e + "' but found '" + k().value + "'") } } function m(e, r) { if (q.indexOf(e) !== -1) { return } var r = r || "IDENTIFIER"; if (k() && k().value === e && k().type === r) { return v() } } function v() { var e = i.shift(); o.push(e); r = e; u(); return e } function h(e, r) { var t = []; var n = y(0, true); while ((r == null || n.type !== r) && (e == null || n.value !== e) && n.type !== "EOF") { var a = i.shift(); o.push(a); t.push(n); n = y(0, true) } u(); return t } function d() { if (o[o.length - 1] && o[o.length - 1].type === "WHITESPACE") { return o[o.length - 1].value } else { return "" } } function E() { return h(null, "WHITESPACE") } function T() { return i.length > 0 } function y(e, r) { var t; var n = 0; do { if (!r) { while (i[n] && i[n].type === "WHITESPACE") { n++ } } t = i[n]; e--; n++ } while (e > -1); if (t) { return t } else { return { type: "EOF", value: "<<<EOF>>>" } } } function k() { return y(0) } function x() { return r } function g() { return e.substring(this.startToken.start, this.endToken.end) } function b() { return e.split("\n")[this.startToken.line - 1] } var q = []; function w(e) { q.push(e) } function N() { q.pop() } function I() { var e = q; q = []; return e } function R(e) { q = e } return { pushFollow: w, popFollow: N, clearFollow: I, restoreFollow: R, matchAnyToken: a, matchAnyOpToken: n, matchOpToken: l, requireOpToken: t, matchTokenType: c, requireTokenType: f, consumeToken: v, matchToken: m, requireToken: p, list: i, consumed: o, source: e, hasMore: T, currentToken: k, lastMatch: x, token: y, consumeUntil: h, consumeUntilWhitespace: E, lastWhitespace: d, sourceFor: g, lineFor: b } } function _(e) { if (e.length > 0) { var r = e[e.length - 1]; if (r.type === "IDENTIFIER" || r.type === "CLASS_REF" || r.type === "ID_REF") { return false } if (r.op && (r.value === ">" || r.value === ")")) { return false } } return true } function e(e, r) { var t = []; var n = e; var a = 0; var i = 0; var o = 1; var u = "<START>"; var s = 0; function l() { return r && s === 0 } while (a < n.length) { if (x() === "-" && g() === "-") { p() } else { if (O(x())) { t.push(w()) } else if (!q() && x() === "." && (L(g()) || g() === "{")) { t.push(m()) } else if (!q() && x() === "#" && (L(g()) || g() === "{")) { t.push(d()) } else if (x() === "[" && g() === "@") { t.push(v()) } else if (x() === "@") { t.push(h()) } else if (L(x()) || !l() && F(x())) { t.push(E()) } else if (C(x())) { t.push(T()) } else if (!l() && (x() === '"' || x() === "`")) { t.push(k()) } else if (!l() && x() === "'") { if (_(t)) { t.push(k()) } else { t.push(y()) } } else if (N[x()]) { if (u === "$" && x() === "{") { s++ } if (x() === "}") { s-- } t.push(y()) } else if (l() || P(x())) { t.push(c("RESERVED", b())) } else { if (a < n.length) { throw Error("Unknown token: " + x() + " ") } } } } return M(t, [], n); function f(e, r) { var t = c(e, r); t.op = true; return t } function c(e, r) { return { type: e, value: r, start: a, end: a + 1, column: i, line: o } } function p() { while (x() && !A(x())) { b() } b() } function m() { var e = c("CLASS_REF"); var r = b(); if (x() === "{") { e.template = true; r += b(); while (x() && x() !== "}") { r += b() } if (x() !== "}") { throw Error("Unterminated class reference") } else { r += b() } } else { while (I(x())) { r += b() } } e.value = r; e.end = a; return e } function v() { var e = c("ATTRIBUTE_REF"); var r = b(); while (a < n.length && x() !== "]") { r += b() } if (x() === "]") { r += b() } e.value = r; e.end = a; return e } function h() { var e = c("ATTRIBUTE_REF"); var r = b(); while (R(x())) { r += b() } e.value = r; e.end = a; return e } function d() { var e = c("ID_REF"); var r = b(); if (x() === "{") { e.template = true; r += b(); while (x() && x() !== "}") { r += b() } if (x() !== "}") { throw Error("Unterminated id reference") } else { b() } } else { while (R(x())) { r += b() } } e.value = r; e.end = a; return e } function E() { var e = c("IDENTIFIER"); var r = b(); while (L(x()) || F(x())) { r += b() } e.value = r; e.end = a; return e } function T() { var e = c("NUMBER"); var r = b(); while (C(x())) { r += b() } if (x() === "." && C(g())) { r += b() } while (C(x())) { r += b() } e.value = r; e.end = a; return e } function y() { var e = f(); var r = b(); while (x() && N[r + x()]) { r += b() } e.type = N[r]; e.value = r; e.end = a; return e } function k() { var e = c("STRING"); var r = b(); var t = ""; while (x() && x() !== r) { if (x() === "\\") { b() } t += b() } if (x() !== r) { throw Error("Unterminated string at " + S(e)) } else { b() } e.value = t; e.end = a; e.template = r === "`"; return e } function x() { return n.charAt(a) } function g() { return n.charAt(a + 1) } function b() { u = x(); a++; i++; return u } function q() { return L(u) || C(u) || u === ")" || u === "}" || u === "]" } function w() { var e = c("WHITESPACE"); var r = ""; while (x() && O(x())) { if (A(x())) { i = 0; o++ } r += b() } e.value = r; e.end = a; return e } } return { tokenize: e, makeTokensObject: M } }(); var U = function () { var u = {}; var o = {}; var s = {}; var a = []; var l = []; function f(e, r, t) { e.startToken = r; e.sourceFor = t.sourceFor; e.lineFor = t.lineFor; e.programSource = t.source } function i(e, r, t) { var n = u[e]; if (n) { var a = r.currentToken(); var i = n(U, z, r, t); if (i) { f(i, a, r); i.endToken = i.endToken || r.lastMatch(); var t = i.root; while (t != null) { f(t, a, r); t = t.root } } return i } } function c(e, r, t, n) { var a = i(e, r, n); return a || h(r, t || "Expected " + e) } function p(e, r) { for (var t = 0; t < e.length; t++) { var n = e[t]; var a = i(n, r); if (a) { return a } } } function t(e, r) { u[e] = r } function e(e, a) { var i = e + "Command"; var r = function (e, r, t) { var n = a(e, r, t); if (n) { n.type = i; n.execute = function (e) { e.meta.command = n; return r.unifiedExec(this, e) }; return n } }; u[i] = r; o[e] = r } function r(a, i) { var o = a + "Feature"; var e = function (e, r, t) { var n = i(e, r, t); if (n) { n.keyword = a; n.type = o; return n } }; u[o] = e; s[a] = e } function n(e, r) { a.push(e); t(e, r) } function m(e, r) { l.push(e); t(e, r) } t("feature", function (e, r, t) { if (t.matchOpToken("(")) { var n = e.requireElement("feature", t); t.requireOpToken(")"); return n } var a = s[t.currentToken().value]; if (a) { return a(e, r, t) } }); t("command", function (e, r, t) { if (t.matchOpToken("(")) { var n = e.requireElement("command", t); t.requireOpToken(")"); return n } var a = o[t.currentToken().value]; if (a) { var n = a(e, r, t) } else if (t.currentToken().type === "IDENTIFIER" && t.token(1).value === "(") { var n = e.requireElement("pseudoCommand", t) } if (n) { return e.parseElement("indirectStatement", t, n) } return n }); t("commandList", function (e, r, t) { var n = e.parseElement("command", t); if (n) { t.matchToken("then"); n.next = e.parseElement("commandList", t); return n } }); t("leaf", function (e, r, t) { var n = p(a, t); if (n == null) { return i("symbol", t) } return n }); t("indirectExpression", function (e, r, t, n) { for (var a = 0; a < l.length; a++) { var i = l[a]; n.endToken = t.lastMatch(); var o = e.parseElement(i, t, n); if (o) { return o } } return n }); t("indirectStatement", function (e, r, t, n) { if (t.matchToken("unless")) { n.endToken = t.lastMatch(); var a = e.requireElement("expression", t); var i = { type: "unlessStatementModifier", args: [a], op: function (e, r) { if (r) { return this.next } else { return n } }, execute: function (e) { return r.unifiedExec(this, e) } }; n.parent = i; return i } return n }); t("primaryExpression", function (e, r, t) { var n = e.parseElement("leaf", t); if (n) { return e.parseElement("indirectExpression", t, n) } e.raiseParseError(t, "Unexpected value: " + t.currentToken().value) }); function v(e) { var r = e.currentToken(); var t = e.source; var n = t.split("\n"); var a = r && r.line ? r.line - 1 : n.length - 1; var i = n[a]; var o = r && r.line ? r.column : i.length - 1; return i + "\n" + " ".repeat(o) + "^^\n\n" } function h(e, r) { r = (r || "Unexpected Token : " + e.currentToken().value) + "\n\n" + v(e); var t = new Error(r); t["tokens"] = e; throw t } function d(e) { var r = i("hyperscript", e); if (e.hasMore()) h(e); return r } function E(e, r) { if (e) { e.parent = r; E(e.next, r) } } function T(e) { return o[e.value] } function y(e) { return s[e.value] } function k(e) { if (e.value == "end" || e.value == "then" || e.value == "else" || e.value == ")" || T(e) || y(e) || e.type == "EOF") { return true } } function x(e) { var r = [""]; do { r.push(e.lastWhitespace()); if (e.currentToken().value === "$") { e.consumeToken(); var t = e.matchOpToken("{"); r.push(c("expression", e)); if (t) { e.requireOpToken("}") } r.push("") } else if (e.currentToken().value === "\\") { e.consumeToken(); e.consumeToken() } else { var n = e.consumeToken(); r[r.length - 1] += n ? n.value : "" } } while (e.hasMore()); r.push(e.lastWhitespace()); return r } return { setParent: E, requireElement: c, parseElement: i, featureStart: y, commandStart: T, commandBoundary: k, parseAnyOf: p, parseHyperScript: d, raiseParseError: h, addGrammarElement: t, addCommand: e, addFeature: r, addLeafExpression: n, addIndirectExpression: m, parseStringTemplate: x } }(); var W = { dynamicResolvers: [], String: function (e) { if (e.toString) { return e.toString() } else { return "" + e } }, Int: function (e) { return parseInt(e) }, Float: function (e) { return parseFloat(e) }, Number: function (e) { console.log(e); return Number(e) }, Date: function (e) { return Date(e) }, Array: function (e) { return Array.from(e) }, JSON: function (e) { return JSON.stringify(e) }, Object: function (e) { if (e instanceof String) { e = e.toString() } if (typeof e === "string") { return JSON.parse(e) } else { return j({}, e) } } }; var z = function () { function t(e, r) { var t = e.matches || e.matchesSelector || e.msMatchesSelector || e.mozMatchesSelector || e.webkitMatchesSelector || e.oMatchesSelector; return t && t.call(e, r) } function i(e, r) { var t; if (window.CustomEvent && typeof window.CustomEvent === "function") { t = new CustomEvent(e, { bubbles: true, cancelable: true, detail: r }) } else { t = document.createEvent("CustomEvent"); t.initCustomEvent(e, true, true, r) } return t } function o(e, r, t) { t = t || {}; t["sentBy"] = e; var n = i(r, t); var a = e.dispatchEvent(n); return a } function s(e) { return Array.isArray(e) || e instanceof NodeList } function n(e, r) { if (e == null) { } else if (s(e)) { for (var t = 0; t < e.length; t++) { r(e[t]) } } else { r(e) } } var u = { array_sentinel: true }; function c(e) { var r = []; for (var t = 0; t < e.length; t++) { var n = e[t]; if (Array.isArray(n)) { r.push(u); for (var a = 0; a < n.length; a++) { r.push(n[a]) } r.push(u) } else { r.push(n) } } return r } function p(e) { var r = []; for (var t = 0; t < e.length; t++) { var n = e[t]; if (n === u) { n = e[++t]; var a = []; r.push(a); while (n !== u) { a.push(n); n = e[++t] } } else { r.push(n) } } return r } function m(e) { for (var r = 0; r < e.length; r++) { var t = e[r]; if (t.asyncWrapper) { e[r] = t.value } if (Array.isArray(t)) { for (var n = 0; n < t.length; n++) { var a = t[n]; if (a.asyncWrapper) { t[n] = a.value } } } } } var l = { halt_flag: true }; function v(r, t) { while (true) { try { var n = e(r, t) } catch (e) { z.registerHyperTrace(t, e); if (t.meta.errorHandler && !t.meta.handlingError) { t.meta.handlingError = true; t[t.meta.errorSymmbol] = e; r = t.meta.errorHandler; continue } else if (t.meta.reject) { t.meta.reject(e); n = l } else { throw e } } if (n == null) { console.error(r, " did not return a next element to execute! context: ", t); return } else if (n.then) { n.then(function (e) { v(e, t) }).catch(function (e) { z.registerHyperTrace(t, e); if (t.meta.errorHandler && !t.meta.handlingError) { t.meta.handlingError = true; t[t.meta.errorSymmbol] = e; v(t.meta.errorHandler, t) } else if (t.meta.reject) { t.meta.reject(e) } else { throw e } }); return } else if (n === l) { return } else { r = n } } } function e(a, r) { var i = [r]; var e = false; var o = false; if (a.args) { for (var t = 0; t < a.args.length; t++) { var n = a.args[t]; if (n == null) { i.push(null) } else if (Array.isArray(n)) { var u = []; for (var s = 0; s < n.length; s++) { var l = n[s]; var f = l ? l.evaluate(r) : null; if (f) { if (f.then) { e = true } else if (f.asyncWrapper) { o = true } } u.push(f) } i.push(u) } else if (n.evaluate) { var f = n.evaluate(r); if (f) { if (f.then) { e = true } else if (f.asyncWrapper) { o = true } } i.push(f) } else { i.push(n) } } } if (e) { return new Promise(function (t, n) { var e = c(i); Promise.all(e).then(function (e) { e = p(e); if (o) { m(e) } try { var r = a.op.apply(a, e); t(r) } catch (e) { n(e) } }).catch(function (e) { if (r.meta.errorHandler && !r.meta.handlingError) { r.meta.handlingError = true; r[r.meta.errorSymmbol] = e; v(r.meta.errorHandler, r) } else if (r.meta.reject) { r.meta.reject(e) } else { } }) }) } else { if (o) { m(i) } return a.op.apply(a, i) } } var r = null; function a() { if (r == null) { r = _hyperscript.config.attributes.replace(/ /g, "").split(",") } return r } function f(e) { for (var r = 0; r < a().length; r++) { var t = a()[r]; if (e.hasAttribute && e.hasAttribute(t)) { return e.getAttribute(t) } } if (e["type"] === "text/hyperscript") { return e.innerText } return null } function h(e, r) { if (e) { if (e.hyperscriptFeatures) { j(r, e.hyperscriptFeatures) } h(e.parentElement, r) } } function d(e, r, t, n) { var a = { meta: { parser: U, lexer: B, runtime: z, owner: e, feature: r, iterators: {} }, me: t, event: n, target: n ? n.target : null, detail: n ? n.detail : null, body: "document" in G ? document.body : null }; a.meta.ctx = a; h(e, a); return a } function E() { return a().map(function (e) { return "[" + e + "]" }).join(", ") } function T(e, r) { var t = W.dynamicResolvers; for (var n = 0; n < t.length; n++) { var a = t[n]; var i = a(r, e); if (i !== undefined) { return i } } if (e == null) { return null } var o = W[r]; if (o) { return o(e) } throw "Unknown conversion : " + r } function y(e, r) { return Object.prototype.toString.call(e) === "[object " + r + "]" } function k(e) { var r = B.tokenize(e); if (U.commandStart(r.currentToken())) { var t = U.parseElement("commandList", r); var n = t; while (n.next) { n = n.next } n.next = { op: function () { return l } }; return t } else if (U.featureStart(r.currentToken())) { var a = U.parseElement("hyperscript", r); return a } else { var i = U.parseElement("expression", r); return i } } function x(e, r) { r = j(d(document.body, null, document.body, null), r || {}); var t = k(e); if (t.execute) { return t.execute(r) } else if (t.apply) { t.apply(document.body, null) } else { return t.evaluate(r) } } function g(e) { var r = z.getScriptSelector(); if (t(e, r)) { b(e, e) } if (e["type"] === "text/hyperscript") { b(e, document.body) } if (e.querySelectorAll) { n(e.querySelectorAll(r + ", [type='text/hyperscript']"), function (e) { b(e, e.type === "text/hyperscript" ? document.body : e) }) } } function b(r, e) { if (r.closest && r.closest(_hyperscript.config.disableSelector)) { return } var t = q(r); if (!t.initialized) { var n = f(r); if (n) { try { t.initialized = true; t.script = n; var a = B.tokenize(n); var i = U.parseHyperScript(a); i.apply(e || r, r); setTimeout(function () { o(e || r, "load", { hyperscript: true }) }, 1) } catch (e) { z.triggerEvent(r, "exception", { error: e }); console.error("hyperscript errors were found on the following element:", r, "\n\n", e.message, e.stack) } } } } function q(e) { var r = "hyperscript-internal-data"; var t = e[r]; if (!t) { t = e[r] = {} } return t } function w(e, r, t) { if (e == null && t) { return true } var n = Object.prototype.toString.call(e).slice(8, -1); return n === r } function N(e) { var r = e.meta.owner; if (r) { var t = q(r); var n = "elementScope"; if (e.meta.feature && e.meta.feature.behavior) { n = e.meta.feature.behavior + "Scope" } var a = H(t, n); return a } else { return {} } } function I(e, r, t) { if (e === "me" || e === "my" || e === "I") { return r["me"] } if (e === "it" || e === "its") { return r["result"] } if (e === "you" || e === "your" || e === "yourself") { return r["beingTold"] } else { if (t === "global") { return G[e] } else if (t === "element") { var n = N(r); return n[e] } else if (t === "local") { return r[e] } else { if (r.meta && r.meta.context) { var a = r.meta.context[e]; if (typeof a !== "undefined") { return a } } var i = r[e]; if (typeof i !== "undefined") { return i } else { var n = N(r); i = n[e]; if (typeof i !== "undefined") { return i } else { return G[e] } } } } } function R(e, r, t, n) { if (t === "global") { G[e] = n } else if (t === "element") { var a = N(r); a[e] = n } else if (t === "local") { r[e] = n } else { var i = r[e]; if (typeof i !== "undefined") { r[e] = n } else { var a = N(r); i = a[e]; if (typeof i !== "undefined") { a[e] = n } else { i = G[e]; if (typeof i !== "undefined") { G[e] = n } else { r[e] = n } } } } } function O(e, r) { if (e) { if (e.resolveNext) { return e.resolveNext(r) } else if (e.next) { return e.next } else { return O(e.parent, r) } } } function S(e, r, t) { if (e != null) { var n = t && e.getAttribute ? e.getAttribute(r) : e[r]; if (typeof n !== "undefined") { return n } if (s(e)) { var a = []; for (var i = 0; i < e.length; i++) { var o = e[i]; var u = t ? o.getAttribute(r) : o[r]; if (u) { a.push(u) } } return a } } } function A(e, r, t, n) { if (typeof document === "undefined" || e === document.body) { var a = G } else { var a = e["hyperscriptFeatures"]; if (a == null) { a = {}; e["hyperscriptFeatures"] = a } } while (r.length > 0) { var i = r.shift(); var o = a[i]; if (o == null) { o = {}; a[i] = o } a = o } a[t] = n } function C(e, r) { var t = []; var n = e; while (n.meta.caller) { n = n.meta.caller } if (n.meta.traceMap) { return n.meta.traceMap.get(r, t) } } function L(e, r) { var a = []; var t = null; while (e != null) { a.push(e); t = e; e = e.meta.caller } if (t.meta.traceMap == null) { t.meta.traceMap = new Map } if (!t.meta.traceMap.get(r)) { var n = { trace: a, print: function (e) { e = e || console.error; e("hypertrace /// "); var r = 0; for (var t = 0; t < a.length; t++) { r = Math.max(r, a[t].meta.feature.displayName.length) } for (var t = 0; t < a.length; t++) { var n = a[t]; e("  ->", n.meta.feature.displayName.padEnd(r + 2), "-", n.meta.owner) } } }; t.meta.traceMap.set(r, n) } } function F(e) { return e.replace(/:/g, function (e) { return "\\" + e }) } function P(e, r) { if (e == null) { throw new Error(r.sourceFor() + " is null") } } function M(e) { return e == undefined || e.length === 0 } function _(e) { var r = e.getRootNode(); if (!(e instanceof Document || e instanceof ShadowRoot)) r = document; return r } var D = "document" in G ? document.currentScript.src : null; return { typeCheck: w, forEach: n, triggerEvent: o, matchesSelector: t, getScript: f, processNode: g, evaluate: x, parse: k, getScriptSelector: E, resolveSymbol: I, setSymbol: R, makeContext: d, findNext: O, unifiedEval: e, convertValue: T, unifiedExec: v, resolveProperty: S, assignToNamespace: A, registerHyperTrace: L, getHyperTrace: C, getInternalData: q, escapeSelector: F, nullCheck: P, isEmpty: M, getRootNode: _, hyperscriptUrl: D, HALT: l } }(); { U.addLeafExpression("parenthesized", function (e, r, t) { if (t.matchOpToken("(")) { var n = t.clearFollow(); try { var a = e.requireElement("expression", t) } finally { t.restoreFollow(n) } t.requireOpToken(")"); return a } }); U.addLeafExpression("string", function (e, r, t) { var n = t.matchTokenType("STRING"); if (!n) return; var a = n.value; if (n.template) { var i = B.tokenize(a, true); var o = e.parseStringTemplate(i) } else { var o = [] } return { type: "string", token: n, args: o, op: function (e) { var r = ""; for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; if (n !== undefined) { r += n } } return r }, evaluate: function (e) { if (o.length === 0) { return a } else { return r.unifiedEval(this, e) } } } }); U.addGrammarElement("nakedString", function (e, r, t) { if (t.hasMore()) { var n = t.consumeUntilWhitespace(); t.matchTokenType("WHITESPACE"); return { type: "nakedString", tokens: n, evaluate: function (e) { return n.map(function (e) { return e.value }).join("") } } } }); U.addLeafExpression("number", function (e, r, t) { var n = t.matchTokenType("NUMBER"); if (!n) return; var a = n; var i = parseFloat(n.value); return { type: "number", value: i, numberToken: a, evaluate: function () { return i } } }); U.addLeafExpression("idRef", function (e, t, r) { var n = r.matchTokenType("ID_REF"); if (!n) return; if (n.template) { var a = n.value.substr(2, n.value.length - 2); var i = B.tokenize(a); var o = e.requireElement("expression", i); return { type: "idRefTemplate", args: [o], op: function (e, r) { return t.getRootNode(e.me).getElementById(r) }, evaluate: function (e) { return t.unifiedEval(this, e) } } } else { return { type: "idRef", css: n.value, value: n.value.substr(1), evaluate: function (e) { return t.getRootNode(e.me).getElementById(this.value) } } } }); U.addLeafExpression("classRef", function (e, t, r) { var n = r.matchTokenType("CLASS_REF"); if (!n) return; if (n.template) { var a = n.value.substr(2, n.value.length - 2); var i = B.tokenize(a); var o = e.requireElement("expression", i); return { type: "classRefTemplate", args: [o], op: function (e, r) { return t.getRootNode(e.me).querySelectorAll(t.escapeSelector("." + r)) }, evaluate: function (e) { return t.unifiedEval(this, e) } } } else { return { type: "classRef", css: n.value, className: function () { return this.css.substr(1) }, evaluate: function (e) { return t.getRootNode(e.me).querySelectorAll(t.escapeSelector(this.css)) } } } }); U.addLeafExpression("queryRef", function (e, u, r) { var t = r.matchOpToken("<"); if (!t) return; var n = r.consumeUntil("/"); r.requireOpToken("/"); r.requireOpToken(">"); var s = n.map(function (e) { if (e.type === "STRING") { return '"' + e.value + '"' } else { return e.value } }).join(""); if (s.indexOf("$") >= 0) { var l = true; var a = B.tokenize(s, true); var i = e.parseStringTemplate(a) } return { type: "queryRef", css: s, args: i, op: function (e, r) { var t = s; var n = []; if (l) { t = ""; for (var a = 1; a < arguments.length; a++) { var i = arguments[a]; if (i) { if (i instanceof Element) { i.dataset.hsQueryId = n.length; t += "[data-hs-query-id='" + n.length + "']"; n.push(i) } else t += i } } } var o = u.getRootNode(e.me).querySelectorAll(t); u.forEach(n, function (e) { e.removeAttribute("data-hs-query-id") }); return o }, evaluate: function (e) { return u.unifiedEval(this, e) } } }); U.addLeafExpression("attributeRef", function (e, r, t) { var n = t.matchTokenType("ATTRIBUTE_REF"); if (!n) return; var a = n.value; if (a.indexOf("[") === 0) { var i = a.substring(2, a.length - 1) } else { var i = a.substring(1) } var o = "[" + i + "]"; var u = i.split("="); var s = u[0]; var l = u[1]; if (l) { if (l.indexOf('"') === 0) { l = l.substring(1, l.length - 1) } } return { type: "attributeRef", name: s, css: o, value: l, op: function (e) { var r = e.beingTold || e.me; if (r) { return r.getAttribute(s) } }, evaluate: function (e) { return r.unifiedEval(this, e) } } }); U.addGrammarElement("objectKey", function (e, r, t) { var n; if (n = t.matchTokenType("STRING")) { return { type: "objectKey", key: n.value, evaluate: function () { return this.key } } } else if (t.matchOpToken("[")) { var a = e.parseElement("expression", t); t.requireOpToken("]"); return { type: "objectKey", expr: a, args: [a], op: function (e, r) { return r }, evaluate: function (e) { return r.unifiedEval(this, e) } } } else { var i = ""; do { n = t.matchTokenType("IDENTIFIER") || t.matchOpToken("-"); if (n) i += n.value } while (n); return { type: "objectKey", key: i, evaluate: function () { return this.key } } } }); U.addLeafExpression("objectLiteral", function (e, r, t) { if (!t.matchOpToken("{")) return; var n = []; var a = []; if (!t.matchOpToken("}")) { do { var i = e.requireElement("objectKey", t); t.requireOpToken(":"); var o = e.requireElement("expression", t); a.push(o); n.push(i) } while (t.matchOpToken(",")); t.requireOpToken("}") } return { type: "objectLiteral", args: [n, a], op: function (e, r, t) { var n = {}; for (var a = 0; a < r.length; a++) { n[r[a]] = t[a] } return n }, evaluate: function (e) { return r.unifiedEval(this, e) } } }); U.addGrammarElement("namedArgumentList", function (e, r, t) { if (!t.matchOpToken("(")) return; var i = []; var n = []; if (!t.matchOpToken(")")) { do { var a = t.requireTokenType("IDENTIFIER"); t.requireOpToken(":"); var o = e.requireElement("expression", t); n.push(o); i.push({ name: a, value: o }) } while (t.matchOpToken(",")); t.requireOpToken(")") } return { type: "namedArgumentList", fields: i, args: [n], op: function (e, r) { var t = { _namedArgList_: true }; for (var n = 0; n < r.length; n++) { var a = i[n]; t[a.name.value] = r[n] } return t }, evaluate: function (e) { return r.unifiedEval(this, e) } } }); U.addGrammarElement("symbol", function (e, r, t) { var n = "default"; if (t.matchToken("global")) { n = "global" } else if (t.matchToken("element")) { n = "element"; if (t.matchOpToken("'")) { t.requireToken("s") } } else if (t.matchToken("local")) { n = "local" } var a = t.matchTokenType("IDENTIFIER"); if (a) { return { type: "symbol", symbolType: n, token: a, name: a.value, evaluate: function (e) { return r.resolveSymbol(a.value, e, n) } } } }); U.addGrammarElement("implicitMeTarget", function (e, r, t) { return { type: "implicitMeTarget", evaluate: function (e) { return e.beingTold || e.me } } }); U.addLeafExpression("boolean", function (e, r, t) { var n = t.matchToken("true") || t.matchToken("false"); if (!n) return; return { type: "boolean", evaluate: function (e) { return n.value === "true" } } }); U.addLeafExpression("null", function (e, r, t) { if (t.matchToken("null")) { return { type: "null", evaluate: function (e) { return null } } } }); U.addLeafExpression("arrayLiteral", function (e, r, t) { if (!t.matchOpToken("[")) return; var n = []; if (!t.matchOpToken("]")) { do { var a = e.requireElement("expression", t); n.push(a) } while (t.matchOpToken(",")); t.requireOpToken("]") } return { type: "arrayLiteral", values: n, args: [n], op: function (e, r) { return r }, evaluate: function (e) { return r.unifiedEval(this, e) } } }); U.addLeafExpression("blockLiteral", function (e, r, t) { if (!t.matchOpToken("\\")) return; var n = []; var a = t.matchTokenType("IDENTIFIER"); if (a) { n.push(a); while (t.matchOpToken(",")) { n.push(t.requireTokenType("IDENTIFIER")) } } t.requireOpToken("-"); t.requireOpToken(">"); var i = e.requireElement("expression", t); return { type: "blockLiteral", args: n, expr: i, evaluate: function (r) { var e = function () { for (var e = 0; e < n.length; e++) { r[n[e].value] = arguments[e] } return i.evaluate(r) }; return e } } }); U.addGrammarElement("timeExpression", function (e, r, t) { var n = e.requireElement("expression", t); var a = 1; if (t.matchToken("s") || t.matchToken("seconds")) { a = 1e3 } else if (t.matchToken("ms") || t.matchToken("milliseconds")) { } return { type: "timeExpression", time: n, factor: a, args: [n], op: function (e, r) { return r * this.factor }, evaluate: function (e) { return r.unifiedEval(this, e) } } }); U.addIndirectExpression("propertyAccess", function (e, n, r, t) { if (!r.matchOpToken(".")) return; var a = r.requireTokenType("IDENTIFIER"); var i = { type: "propertyAccess", root: t, prop: a, args: [t], op: function (e, r) { var t = n.resolveProperty(r, a.value); return t }, evaluate: function (e) { return n.unifiedEval(this, e) } }; return e.parseElement("indirectExpression", r, i) }); U.addIndirectExpression("of", function (e, t, r, n) { if (!r.matchToken("of")) return; var a = e.requireElement("expression", r); var i = null; var o = n; while (o.root) { i = o; o = o.root } if (o.type !== "symbol" && o.type !== "attributeRef") { e.raiseParseError(r, "Cannot take a property of a non-symbol: " + o.type) } var u = o.type === "attributeRef"; var s = o.name; var l = { type: "ofExpression", prop: o.token, root: a, attribute: u, expression: n, args: [a], op: function (e, r) { return t.resolveProperty(r, s, u) }, evaluate: function (e) { return t.unifiedEval(this, e) } }; if (o.type === "attributeRef") { l.attribute = o } if (i) { i.root = l; i.args = [l] } else { n = l } return e.parseElement("indirectExpression", r, n) }); U.addIndirectExpression("possessive", function (e, n, r, t) { if (e.possessivesDisabled) { return } var a = r.matchOpToken("'"); if (a || t.type === "symbol" && (t.name === "my" || t.name === "its" || t.name === "your") && r.currentToken().type === "IDENTIFIER") { if (a) { r.requireToken("s") } var i = e.parseElement("attributeRef", r); if (i == null) { var o = r.requireTokenType("IDENTIFIER") } var u = { type: "possessive", root: t, attribute: i, prop: o, args: [t], op: function (e, r) { if (i) { var t = n.resolveProperty(r, i.name, true) } else { var t = n.resolveProperty(r, o.value, false) } return t }, evaluate: function (e) { return n.unifiedEval(this, e) } }; return e.parseElement("indirectExpression", r, u) } }); U.addIndirectExpression("inExpression", function (e, a, r, i) { if (!r.matchToken("in")) return; if (i.type !== "idRef" && i.type === "queryRef" || i.type === "classRef") { var o = true } var t = e.requireElement("expression", r); var n = { type: "inExpression", root: i, args: [o ? null : i, t], op: function (e, r, t) { var n = []; if (o) { a.forEach(t, function (e) { var r = e.querySelectorAll(i.css); for (var t = 0; t < r.length; t++) { n.push(r[t]) } }) } else { a.forEach(r, function (r) { a.forEach(t, function (e) { if (r === e) { n.push(r) } }) }) } if (n.length > 0) { return n } else { return null } }, evaluate: function (e) { return a.unifiedEval(this, e) } }; return e.parseElement("indirectExpression", r, n) }); U.addIndirectExpression("asExpression", function (e, t, r, n) { if (!r.matchToken("as")) return; var a = e.requireElement("dotOrColonPath", r).evaluate(); var i = { type: "asExpression", root: n, args: [n], op: function (e, r) { return t.convertValue(r, a) }, evaluate: function (e) { return t.unifiedEval(this, e) } }; return e.parseElement("indirectExpression", r, i) }); U.addIndirectExpression("functionCall", function (e, a, r, i) { if (!r.matchOpToken("(")) return; var t = []; if (!r.matchOpToken(")")) { do { t.push(e.requireElement("expression", r)) } while (r.matchOpToken(",")); r.requireOpToken(")") } if (i.root) { var n = { type: "functionCall", root: i, argExressions: t, args: [i.root, t], op: function (e, r, t) { a.nullCheck(r, i.root); var n = r[i.prop.value]; a.nullCheck(n, i); if (n.hyperfunc) { t.push(e) } return n.apply(r, t) }, evaluate: function (e) { return a.unifiedEval(this, e) } } } else { var n = { type: "functionCall", root: i, argExressions: t, args: [i, t], op: function (e, r, t) { a.nullCheck(r, i); if (r.hyperfunc) { t.push(e) } var n = r.apply(null, t); return n }, evaluate: function (e) { return a.unifiedEval(this, e) } } } return e.parseElement("indirectExpression", r, n) }); U.addIndirectExpression("attributeRefAccess", function (e, n, r, t) { var a = e.parseElement("attributeRef", r); if (!a) return; var i = { type: "attributeRefAccess", root: t, attribute: a, args: [t], op: function (e, r) { var t = n.resolveProperty(r, a.name, true); return t }, evaluate: function (e) { return z.unifiedEval(this, e) } }; return i }); U.addIndirectExpression("arrayIndex", function (e, r, t, n) { if (!t.matchOpToken("[")) return; var a = false; var i = false; var o = null; var u = null; if (t.matchOpToken("..")) { a = true; o = e.requireElement("expression", t) } else { o = e.requireElement("expression", t); if (t.matchOpToken("..")) { i = true; var s = t.currentToken(); if (s.type !== "R_BRACKET") { u = e.parseElement("expression", t) } } } t.requireOpToken("]"); var l = { type: "arrayIndex", root: n, firstIndex: o, secondIndex: u, args: [n, o, u], op: function (e, r, t, n) { if (a) { return r.slice(0, t + 1) } else if (i) { if (n != null) { return r.slice(t, n + 1) } else { return r.slice(t) } } else { return r[t] } }, evaluate: function (e) { return z.unifiedEval(this, e) } }; return U.parseElement("indirectExpression", t, l) }); U.addGrammarElement("postfixExpression", function (e, n, r) { var t = e.parseElement("primaryExpression", r); if (r.matchOpToken(":")) { var a = r.requireTokenType("IDENTIFIER"); var i = !r.matchOpToken("!"); return { type: "typeCheck", typeName: a, root: t, nullOk: i, args: [t], op: function (e, r) { var t = n.typeCheck(r, this.typeName.value, this.nullOk); if (t) { return r } else { throw new Error("Typecheck failed!  Expected: " + this.typeName.value) } }, evaluate: function (e) { return n.unifiedEval(this, e) } } } else { return t } }); U.addGrammarElement("logicalNot", function (e, r, t) { if (!t.matchToken("not")) return; var n = e.requireElement("unaryExpression", t); return { type: "logicalNot", root: n, args: [n], op: function (e, r) { return !r }, evaluate: function (e) { return r.unifiedEval(this, e) } } }); U.addGrammarElement("noExpression", function (e, t, r) { if (!r.matchToken("no")) return; var n = e.requireElement("unaryExpression", r); return { type: "noExpression", root: n, args: [n], op: function (e, r) { return t.isEmpty(r) }, evaluate: function (e) { return t.unifiedEval(this, e) } } }); U.addGrammarElement("negativeNumber", function (e, r, t) { if (!t.matchOpToken("-")) return; var n = e.requireElement("unaryExpression", t); return { type: "negativeNumber", root: n, args: [n], op: function (e, r) { return -1 * r }, evaluate: function (e) { return r.unifiedEval(this, e) } } }); U.addGrammarElement("unaryExpression", function (e, r, t) { return e.parseAnyOf(["logicalNot", "relativePositionalExpression", "positionalExpression", "noExpression", "negativeNumber", "postfixExpression"], t) }); U.addGrammarElement("relativePositionalExpression", function (e, r, t) { var n = t.matchAnyToken("next", "previous"); if (!n) return; if (n.value === "next") { var u = "nextElementSibling" } else { var u = "previousElementSibling" } var a = e.parseElement("expression", t); var i = a.css; if (i == null) { e.raiseParseError(t, "Expected a CSS expression") } if (t.matchToken("from")) { var o = e.requireElement("expression", t) } else { var o = e.requireElement("implicitMeTarget", t) } if (t.matchToken("within")) { var s = e.requireElement("expression", t) } else { var s = document.body } return { type: "relativePositionalExpression", from: o, inElt: s, operator: n.value, propName: u, args: [i, o, s], op: function (e, r, t, n) { var a = t; while (a && a !== n) { var i = a[u]; while (i) { if (i.matches(r)) { return i } else { var o = i.querySelector(r); if (o) { return o } } i = i[u] } a = a.parentElement } }, evaluate: function (e) { return r.unifiedEval(this, e) } } }); U.addGrammarElement("positionalExpression", function (e, r, t) { var n = t.matchAnyToken("first", "last", "random"); if (!n) return; t.matchAnyToken("in", "from", "of"); var a = e.requireElement("unaryExpression", t); return { type: "positionalExpression", rhs: a, operator: n.value, args: [a], op: function (e, r) { if (r && !Array.isArray(r)) { if (r.children) { r = r.children } else { r = Array.from(r) } } if (r) { if (this.operator === "first") { return r[0] } else if (this.operator === "last") { return r[r.length - 1] } else if (this.operator === "random") { return r[Math.floor(Math.random() * r.length)] } } }, evaluate: function (e) { return r.unifiedEval(this, e) } } }); U.addGrammarElement("mathOperator", function (e, r, t) { var n = e.parseElement("unaryExpression", t); var a, i = null; a = t.matchAnyOpToken("+", "-", "*", "/", "%"); while (a) { i = i || a; var o = a.value; if (i.value !== o) { e.raiseParseError(t, "You must parenthesize math operations with different operators") } var u = e.parseElement("unaryExpression", t); n = { type: "mathOperator", lhs: n, rhs: u, operator: o, args: [n, u], op: function (e, r, t) { if (this.operator === "+") { return r + t } else if (this.operator === "-") { return r - t } else if (this.operator === "*") { return r * t } else if (this.operator === "/") { return r / t } else if (this.operator === "%") { return r % t } }, evaluate: function (e) { return r.unifiedEval(this, e) } }; a = t.matchAnyOpToken("+", "-", "*", "/", "%") } return n }); U.addGrammarElement("mathExpression", function (e, r, t) { return e.parseAnyOf(["mathOperator", "unaryExpression"], t) }); U.addGrammarElement("comparisonOperator", function (e, n, r) { var t = e.parseElement("mathExpression", r); var a = r.matchAnyOpToken("<", ">", "<=", ">=", "==", "===", "!=", "!=="); var i = a ? a.value : null; var o = true; var u = false; if (i == null) { if (r.matchToken("is") || r.matchToken("am")) { if (r.matchToken("not")) { if (r.matchToken("in")) { i = "not in" } else if (r.matchToken("a")) { i = "not a"; u = true } else if (r.matchToken("empty")) { i = "not empty"; o = false } else { i = "!=" } } else if (r.matchToken("in")) { i = "in" } else if (r.matchToken("a")) { i = "a"; u = true } else if (r.matchToken("empty")) { i = "empty"; o = false } else { i = "==" } } else if (r.matchToken("matches") || r.matchToken("match")) { i = "match" } else if (r.matchToken("contains") || r.matchToken("contain")) { i = "contain" } else if (r.matchToken("do") || r.matchToken("does")) { r.requireToken("not"); if (r.matchToken("matches") || r.matchToken("match")) { i = "not match" } else if (r.matchToken("contains") || r.matchToken("contain")) { i = "not contain" } else { e.raiseParseError(r, "Expected matches or contains") } } } if (i) { if (u) { var s = r.requireTokenType("IDENTIFIER"); var l = !r.matchOpToken("!") } else if (o) { var f = e.requireElement("mathExpression", r); if (i === "match" || i === "not match") { f = f.css ? f.css : f } } t = { type: "comparisonOperator", operator: i, typeName: s, nullOk: l, lhs: t, rhs: f, args: [t, f], op: function (e, r, t) { if (this.operator === "==") { return r == t } else if (this.operator === "!=") { return r != t } if (this.operator === "in") { return t != null && Array.from(t).indexOf(r) >= 0 } if (this.operator === "not in") { return t == null || Array.from(t).indexOf(r) < 0 } if (this.operator === "match") { return r != null && r.matches(t) } if (this.operator === "not match") { return r == null || !r.matches(t) } if (this.operator === "contain") { return r != null && r.contains(t) } if (this.operator === "not contain") { return r == null || !r.contains(t) } if (this.operator === "===") { return r === t } else if (this.operator === "!==") { return r !== t } else if (this.operator === "<") { return r < t } else if (this.operator === ">") { return r > t } else if (this.operator === "<=") { return r <= t } else if (this.operator === ">=") { return r >= t } else if (this.operator === "empty") { return n.isEmpty(r) } else if (this.operator === "not empty") { return !n.isEmpty(r) } else if (this.operator === "a") { return n.typeCheck(r, this.typeName.value, this.nullOk) } else if (this.operator === "not a") { return !n.typeCheck(r, this.typeName.value, this.nullOk) } else { throw "Unknown comparison : " + this.operator } }, evaluate: function (e) { return n.unifiedEval(this, e) } } } return t }); U.addGrammarElement("comparisonExpression", function (e, r, t) { return e.parseAnyOf(["comparisonOperator", "mathExpression"], t) }); U.addGrammarElement("logicalOperator", function (e, r, t) { var n = e.parseElement("comparisonExpression", t); var a, i = null; a = t.matchToken("and") || t.matchToken("or"); while (a) { i = i || a; if (i.value !== a.value) { e.raiseParseError(t, "You must parenthesize logical operations with different operators") } var o = e.requireElement("comparisonExpression", t); n = { type: "logicalOperator", operator: a.value, lhs: n, rhs: o, args: [n, o], op: function (e, r, t) { if (this.operator === "and") { return r && t } else { return r || t } }, evaluate: function (e) { return r.unifiedEval(this, e) } }; a = t.matchToken("and") || t.matchToken("or") } return n }); U.addGrammarElement("logicalExpression", function (e, r, t) { return e.parseAnyOf(["logicalOperator", "mathExpression"], t) }); U.addGrammarElement("asyncExpression", function (e, r, t) { if (t.matchToken("async")) { var n = e.requireElement("logicalExpression", t); var a = { type: "asyncExpression", value: n, evaluate: function (e) { return { asyncWrapper: true, value: this.value.evaluate(e) } } }; return a } else { return e.parseElement("logicalExpression", t) } }); U.addGrammarElement("expression", function (e, r, t) { t.matchToken("the"); return e.parseElement("asyncExpression", t) }); U.addGrammarElement("assignableExpression", function (e, r, t) { t.matchToken("the"); var n = e.parseElement("primaryExpression", t); if (n.type === "symbol" || n.type === "ofExpression" || n.type === "propertyAccess" || n.type === "attributeRefAccess" || n.type === "attributeRef" || n.type === "possessive") { return n } else { U.raiseParseError(t, "A target expression must be writable.  The expression type '" + n.type + "' is not.") } return n }); U.addGrammarElement("hyperscript", function (e, r, t) { var a = []; if (t.hasMore()) { while (e.featureStart(t.currentToken()) || t.currentToken().value === "(") { var n = e.requireElement("feature", t); a.push(n); t.matchToken("end") } } return { type: "hyperscript", features: a, apply: function (r, t, n) { z.forEach(a, function (e) { e.install(r, t, n) }) } } }); var L = function (e) { var r = []; if (e.token(0).value === "(" && (e.token(1).value === ")" || e.token(2).value === "," || e.token(2).value === ")")) { e.matchOpToken("("); do { r.push(e.requireTokenType("IDENTIFIER")) } while (e.matchOpToken(",")); e.requireOpToken(")") } return r }; U.addFeature("on", function (e, f, r) { if (!r.matchToken("on")) return; var t = false; if (r.matchToken("every")) { t = true } var n = []; var a = null; do { var i = e.requireElement("eventName", r, "Expected event name"); var o = i.evaluate(); if (a) { a = a + " or " + o } else { a = "on " + o } var u = L(r); var s = null; if (r.matchOpToken("[")) { s = e.requireElement("expression", r); r.requireOpToken("]") } if (r.currentToken().type === "NUMBER") { var l = r.consumeToken(); var c = parseInt(l.value); if (r.matchToken("to")) { var p = r.consumeToken(); var m = parseInt(p.value) } else if (r.matchToken("and")) { var v = true; r.requireToken("on") } } if (o === "intersection") { var h = {}; if (r.matchToken("with")) { h["with"] = e.parseElement("expression", r).evaluate() } if (r.matchToken("having")) { do { if (r.matchToken("margin")) { h["rootMargin"] = e.parseElement("stringLike", r).evaluate() } else if (r.matchToken("threshold")) { h["threshold"] = e.parseElement("expression", r).evaluate() } else { e.raiseParseError(r, "Unknown intersection config specification") } } while (r.matchToken("and")) } } else if (o === "mutation") { var d = {}; if (r.matchToken("of")) { do { if (r.matchToken("anything")) { d["attributes"] = true; d["subtree"] = true; d["characterData"] = true; d["childList"] = true } else if (r.matchToken("childList")) { d["childList"] = true } else if (r.matchToken("attributes")) { d["attributes"] = true; d["attributeOldValue"] = true } else if (r.matchToken("subtree")) { d["subtree"] = true } else if (r.matchToken("characterData")) { d["characterData"] = true; d["characterDataOldValue"] = true } else if (r.currentToken().type === "ATTRIBUTE_REF") { var E = r.consumeToken(); if (d["attributeFilter"] == null) { d["attributeFilter"] = [] } if (E.value.indexOf("@") == 0) { d["attributeFilter"].push(E.value.substring(1)) } else { e.raiseParseError(r, "Only shorthand attribute references are allowed here") } } else { e.raiseParseError(r, "Unknown mutation config specification") } } while (r.matchToken("or")) } else { d["attributes"] = true; d["characterData"] = true; d["childList"] = true } } var T = null; var y = false; if (r.matchToken("from")) { if (r.matchToken("elsewhere")) { y = true } else { T = e.parseElement("expression", r); if (!T) { e.raiseParseError('Expected either target value or "elsewhere".', r) } } } if (T === null && y === false && r.matchToken("elsewhere")) { y = true } if (r.matchToken("in")) { var k = e.parseAnyOf(["idRef", "queryRef", "classRef"], r) } if (r.matchToken("debounced")) { r.requireToken("at"); var x = e.requireElement("timeExpression", r); var g = x.evaluate({}) } else if (r.matchToken("throttled")) { r.requireToken("at"); var x = e.requireElement("timeExpression", r); var b = x.evaluate({}) } n.push({ execCount: 0, every: t, on: o, args: u, filter: s, from: T, inExpr: k, elsewhere: y, startCount: c, endCount: m, unbounded: v, debounceTime: g, throttleTime: b, mutationSpec: d, intersectionSpec: h }) } while (r.matchToken("or")); var q = []; var w = true; if (!t) { if (r.matchToken("queue")) { if (r.matchToken("all")) { var N = true; var w = false } else if (r.matchToken("first")) { var I = true } else if (r.matchToken("none")) { var R = true } else { r.requireToken("last") } } } var O = e.requireElement("commandList", r); var S = { type: "implicitReturn", op: function (e) { e.meta.resolve(); return f.HALT }, execute: function (e) { } }; if (O) { var A = O; while (A.next) { A = A.next } A.next = S } else { O = S } var C = { displayName: a, events: n, start: O, every: t, executing: false, execCount: 0, queue: q, execute: function (n) { if (this.executing && this.every === false) { if (R || I && q.length > 0) { return } if (w) { C.queue.length = 0 } C.queue.push(n); return } this.execCount++; this.executing = true; n.meta.resolve = function () { C.executing = false; var e = C.queue.shift(); if (e) { setTimeout(function () { C.execute(e) }, 1) } }; n.meta.reject = function (e) { console.error(e.message ? e.message : e); var r = f.getHyperTrace(n, e); if (r) { r.print() } f.triggerEvent(n.me, "exception", { error: e }); C.executing = false; var t = C.queue.shift(); if (t) { setTimeout(function () { C.execute(t) }, 1) } }; O.execute(n) }, install: function (l, e) { f.forEach(C.events, function (s) { var e; if (s.elsewhere) { e = [document] } else if (s.from) { e = s.from.evaluate({ me: l }) } else { e = [l] } f.forEach(e, function (o) { var u = s.on; if (s.mutationSpec) { u = "hyperscript:mutation"; var t = new MutationObserver(function (e, r) { console.log(o, e); if (!C.executing) { z.triggerEvent(o, u, { mutationList: e, observer: r }) } }); t.observe(o, s.mutationSpec) } if (s.intersectionSpec) { u = "hyperscript:insersection"; var t = new IntersectionObserver(function (e) { z.forEach(e, function (e) { var r = { observer: t }; r = j(r, e); r["intersecting"] = e.isIntersecting; z.triggerEvent(o, u, r) }) }, s.intersectionSpec); t.observe(o) } o.addEventListener(u, function e(r) { if (l instanceof Node && o !== l && !l.isConnected) { o.removeEventListener(u, e); return } var t = f.makeContext(l, C, l, r); if (s.elsewhere && l.contains(r.target)) { return } if (s.from) { t.result = o } f.forEach(s.args, function (e) { t[e.value] = t.event[e.value] || (t.event.detail ? t.event.detail[e.value] : null) }); if (s.filter) { var n = t.meta.context; t.meta.context = t.event; try { var a = s.filter.evaluate(t); if (a) { } else { return } } finally { t.meta.context = n } } if (s.inExpr) { var i = r.target; while (true) { if (i.matches && i.matches(s.inExpr.css)) { t.result = i; break } else { i = i.parentElement; if (i == null) { return } } } } s.execCount++; if (s.startCount) { if (s.endCount) { if (s.execCount < s.startCount || s.execCount > s.endCount) { return } } else if (s.unbounded) { if (s.execCount < s.startCount) { return } } else if (s.execCount !== s.startCount) { return } } if (s.debounceTime) { if (s.debounced) { clearTimeout(s.debounced) } s.debounced = setTimeout(function () { C.execute(t) }, s.debounceTime); return } if (s.throttleTime) { if (s.lastExec && Date.now() < s.lastExec + s.throttleTime) { return } else { s.lastExec = Date.now() } } C.execute(t) }) }) }) } }; e.setParent(O, C); return C }); U.addFeature("def", function (e, l, r) { if (!r.matchToken("def")) return; var t = e.requireElement("dotOrColonPath", r); var n = t.evaluate(); var a = n.split("."); var i = a.pop(); var f = []; if (r.matchOpToken("(")) { if (r.matchOpToken(")")) { } else { do { f.push(r.requireTokenType("IDENTIFIER")) } while (r.matchOpToken(",")); r.requireOpToken(")") } } var c = e.parseElement("commandList", r); if (r.matchToken("catch")) { var p = r.requireTokenType("IDENTIFIER").value; var m = e.parseElement("commandList", r) } var v = { displayName: i + "(" + f.map(function (e) { return e.value }).join(", ") + ")", name: i, args: f, start: c, errorHandler: m, errorSymbol: p, install: function (u, s) { var e = function () { var e = l.makeContext(s, v, u, null); e.meta.errorHandler = m; e.meta.errorSymmbol = p; for (var r = 0; r < f.length; r++) { var t = f[r]; var n = arguments[r]; if (t) { e[t.value] = n } } e.meta.caller = arguments[f.length]; if (e.meta.caller) { e.meta.callingCommand = e.meta.caller.meta.command } var a, i = null; var o = new Promise(function (e, r) { a = e; i = r }); c.execute(e); if (e.meta.returned) { return e.meta.returnValue } else { e.meta.resolve = a; e.meta.reject = i; return o } }; e.hyperfunc = true; e.hypername = n; l.assignToNamespace(u, a, i, e) } }; var o = { type: "implicitReturn", op: function (e) { e.meta.returned = true; if (e.meta.resolve) { e.meta.resolve() } return l.HALT }, execute: function (e) { } }; if (c) { var u = c; while (u.next) { u = u.next } u.next = o } else { v.start = o } if (m) { var u = m; while (u.next) { u = u.next } u.next = o } e.setParent(c, v); return v }); U.addFeature("init", function (e, t, r) { if (!r.matchToken("init")) return; var n = e.parseElement("commandList", r); var a = { start: n, install: function (e, r) { setTimeout(function () { n.execute(t.makeContext(e, this, e, null)) }, 0) } }; var i = { type: "implicitReturn", op: function (e) { return t.HALT }, execute: function (e) { } }; if (n) { var o = n; while (o.next) { o = o.next } o.next = i } else { a.start = i } e.setParent(n, a); return a }); U.addFeature("worker", function (e, r, t) { if (t.matchToken("worker")) { e.raiseParseError(t, "In order to use the 'worker' feature, include " + "the _hyperscript worker plugin. See " + "https://hyperscript.org/features/worker/ for " + "more info.") } }); U.addFeature("behavior", function (e, o, r) { if (!r.matchToken("behavior")) return; var u = e.parseElement("dotOrColonPath", r).evaluate(); var t = u.split("."); var n = t.pop(); var s = []; if (r.matchOpToken("(") && !r.matchOpToken(")")) { do { s.push(r.requireTokenType("IDENTIFIER").value) } while (r.matchOpToken(",")); r.requireOpToken(")") } var l = e.parseElement("hyperscript", r); for (var a = 0; a < l.features.length; a++) { var i = l.features[a]; i.behavior = u } return { install: function (e, r) { o.assignToNamespace(G.document && G.document.body, t, n, function (e, r, t) { var n = o.getInternalData(e); var a = H(n, u + "Scope"); for (var i = 0; i < s.length; i++) { a[s[i]] = t[s[i]] } l.apply(e, r) }) } } }); U.addFeature("install", function (e, r, t) { if (!t.matchToken("install")) return; var o = e.requireElement("dotOrColonPath", t).evaluate(); var u = o.split("."); var n = e.parseElement("namedArgumentList", t); var s; return s = { install: function (a, i) { r.unifiedEval({ args: [n], op: function (e, r) { var t = G; for (var n = 0; n < u.length; n++) { t = t[u[n]]; if (typeof t !== "object" && typeof t !== "function") throw new Error("No such behavior defined as " + o) } if (!(t instanceof Function)) throw new Error(o + " is not a behavior"); t(a, i, r) } }, r.makeContext(a, s, a)) } } }); U.addGrammarElement("jsBody", function (e, r, t) { var n = t.currentToken().start; var a = t.currentToken(); var i = []; var o = ""; var u = false; while (t.hasMore()) { a = t.consumeToken(); var s = t.currentToken(true); if (s.type === "IDENTIFIER" && s.value === "end") { break } if (u) { if (a.type === "IDENTIFIER" || a.type === "NUMBER") { o += a.value } else { if (o !== "") i.push(o); o = ""; u = false } } else if (a.type === "IDENTIFIER" && a.value === "function") { u = true } } var l = a.end + 1; return { type: "jsBody", exposedFunctionNames: i, jsSource: t.source.substring(n, l) } }); U.addFeature("js", function (e, r, t) { if (!t.matchToken("js")) return; var n = e.parseElement("jsBody", t); var a = n.jsSource + "\nreturn { " + n.exposedFunctionNames.map(function (e) { return e + ":" + e }).join(",") + " } "; var i = new Function(a); return { jsSource: a, function: i, exposedFunctionNames: n.exposedFunctionNames, install: function () { j(G, i()) } } }); U.addCommand("js", function (e, n, r) { if (!r.matchToken("js")) return; var a = []; if (r.matchOpToken("(")) { if (r.matchOpToken(")")) { } else { do { var t = r.requireTokenType("IDENTIFIER"); a.push(t.value) } while (r.matchOpToken(",")); r.requireOpToken(")") } } var i = e.parseElement("jsBody", r); r.matchToken("end"); var o = u(Function, a.concat([i.jsSource])); return { jsSource: i.jsSource, function: o, inputs: a, op: function (t) { var r = []; a.forEach(function (e) { r.push(n.resolveSymbol(e, t)) }); var e = o.apply(G, r); if (e && typeof e.then === "function") { return Promise(function (r) { e.then(function (e) { t.result = e; r(n.findNext(this, t)) }) }) } else { t.result = e; return n.findNext(this, t) } } } }); U.addCommand("async", function (e, r, t) { if (!t.matchToken("async")) return; if (t.matchToken("do")) { var n = e.requireElement("commandList", t); t.requireToken("end") } else { var n = e.requireElement("command", t) } return { body: n, op: function (e) { setTimeout(function () { n.execute(e) }); return r.findNext(this, e) } } }); U.addCommand("tell", function (e, t, r) { var n = r.currentToken(); if (!r.matchToken("tell")) return; var a = e.requireElement("expression", r); var i = e.requireElement("commandList", r); if (r.hasMore()) { r.requireToken("end") } var o = "tell_" + n.start; var u = { value: a, body: i, args: [a], resolveNext: function (e) { var r = e.meta.iterators[o]; if (r.index < r.value.length) { e.beingTold = r.value[r.index++]; return i } else { e.beingTold = r.originalBeingTold; if (this.next) { return this.next } else { return t.findNext(this.parent, e) } } }, op: function (e, r) { if (r == null) { r = [] } else if (!(Array.isArray(r) || r instanceof NodeList)) { r = [r] } e.meta.iterators[o] = { originalBeingTold: e.beingTold, index: 0, value: r }; return this.resolveNext(e) } }; e.setParent(i, u); return u }); U.addCommand("wait", function (e, o, r) { if (!r.matchToken("wait")) return; if (r.matchToken("for")) { r.matchToken("a"); var u = []; do { u.push({ name: U.requireElement("dotOrColonPath", r, "Expected event name").evaluate(), args: L(r) }) } while (r.matchToken("or")); if (r.matchToken("from")) { var t = e.requireElement("expression", r) } var s = { event: u, on: t, args: [t], op: function (a, e) { var i = e ? e : a.me; if (!(i instanceof EventTarget)) throw new Error("Not a valid event target: " + this.on.sourceFor()); return new Promise(function (t) { var n = false; o.forEach(u, function (e) { var r = function (r) { a.result = r; o.forEach(e.args, function (e) { a[e.value] = r[e.value] || (r.detail ? r.detail[e.value] : null) }); if (!n) { n = true; t(o.findNext(s, a)) } }; i.addEventListener(e.name, r, { once: true }) }) }) } } } else { if (r.matchToken("a")) { r.requireToken("tick"); n = 0 } else { var n = U.requireElement("timeExpression", r) } var s = { type: "waitCmd", time: n, args: [n], op: function (r, t) { return new Promise(function (e) { setTimeout(function () { e(o.findNext(s, r)) }, t) }) }, execute: function (e) { return o.unifiedExec(this, e) } } } return s }); U.addGrammarElement("dotOrColonPath", function (e, r, t) { var n = t.matchTokenType("IDENTIFIER"); if (n) { var a = [n.value]; var i = t.matchOpToken(".") || t.matchOpToken(":"); if (i) { do { a.push(t.requireTokenType("IDENTIFIER").value) } while (t.matchOpToken(i.value)) } return { type: "dotOrColonPath", path: a, evaluate: function () { return a.join(i ? i.value : "") } } } }); U.addGrammarElement("eventName", function (e, r, t) { var n; if (n = t.matchTokenType("STRING")) { return { evaluate: function () { return n.value } } } return e.parseElement("dotOrColonPath", t) }); U.addCommand("send", function (e, a, r) { if (!r.matchToken("send")) return; var t = e.requireElement("eventName", r); var n = e.parseElement("namedArgumentList", r); if (r.matchToken("to")) { var i = e.requireElement("expression", r) } else { var i = e.requireElement("implicitMeTarget", r) } var o = { eventName: t, details: n, to: i, args: [i, t, n], op: function (e, r, t, n) { a.forEach(r, function (e) { a.triggerEvent(e, t, n ? n : {}) }); return a.findNext(o, e) } }; return o }); var s = function (e, n, r, t) { if (t) { var a = e.requireElement("expression", r) } var i = { value: a, args: [a], op: function (e, r) { var t = e.meta.resolve; e.meta.returned = true; if (t) { if (r) { t(r) } else { t() } } else { e.meta.returned = true; e.meta.returnValue = r } return n.HALT } }; return i }; U.addCommand("return", function (e, r, t) { if (t.matchToken("return")) { return s(e, r, t, true) } }); U.addCommand("exit", function (e, r, t) { if (t.matchToken("exit")) { return s(e, r, t, false) } }); U.addCommand("halt", function (e, r, t) { if (t.matchToken("halt")) { if (t.matchToken("the")) { t.requireToken("event"); if (t.matchOpToken("'")) { t.requireToken("s") } var n = true } if (t.matchToken("bubbling")) { var a = true } else if (t.matchToken("default")) { var i = true } var o = s(e, r, t, false); var u = { keepExecuting: true, bubbling: a, haltDefault: i, exit: o, op: function (e) { if (e.event) { if (a) { e.event.stopPropagation() } else if (i) { e.event.preventDefault() } else { e.event.stopPropagation(); e.event.preventDefault() } if (n) { return r.findNext(this, e) } else { return o } } } }; return u } }); U.addCommand("log", function (e, n, r) { if (!r.matchToken("log")) return; var t = [e.parseElement("expression", r)]; while (r.matchOpToken(",")) { t.push(e.requireElement("expression", r)) } if (r.matchToken("with")) { var a = e.requireElement("expression", r) } var i = { exprs: t, withExpr: a, args: [a, t], op: function (e, r, t) { if (r) { r.apply(null, t) } else { console.log.apply(null, t) } return n.findNext(this, e) } }; return i }); U.addCommand("throw", function (e, n, r) { if (!r.matchToken("throw")) return; var t = e.requireElement("expression", r); var a = { expr: t, args: [t], op: function (e, r) { n.registerHyperTrace(e, r); var t = e.meta && e.meta.reject; if (t) { t(r); return n.HALT } else { throw r } } }; return a }); var a = function (e, t, r) { var n = e.requireElement("expression", r); var a = { expr: n, args: [n], op: function (e, r) { e.result = r; return t.findNext(a, e) } }; return a }; U.addCommand("call", function (e, r, t) { if (!t.matchToken("call")) return; var n = a(e, r, t); if (n.expr && n.expr.type !== "functionCall") { e.raiseParseError(t, "Must be a function invocation") } return n }); U.addCommand("get", function (e, r, t) { if (t.matchToken("get")) { return a(e, r, t) } }); U.addCommand("make", function (e, l, r) { if (!r.matchToken("make")) return; r.matchToken("a") || r.matchToken("an"); var f = e.requireElement("expression", r); var t = []; if (f.type !== "queryRef" && r.matchToken("from")) { do { t.push(e.requireElement("expression", r)) } while (r.matchOpToken(",")) } if (r.matchToken("called")) { var c = r.requireTokenType("IDENTIFIER").value } if (f.type === "queryRef") return { op: function (e) { var r, t = "div", n, a = []; var i = /(?:(^|#|\.)([^#\. ]+))/g; while (r = i.exec(f.css)) { if (r[1] === "") t = r[2].trim(); else if (r[1] === "#") n = r[2].trim(); else a.push(r[2].trim()) } var o = document.createElement(t); if (n !== undefined) o.id = n; for (var u = 0; u < a.length; u++) { var s = a[u]; o.classList.add(s) } e.result = o; if (c) e[c] = o; return l.findNext(this, e) } }; else return { args: [f, t], op: function (e, r, t) { e.result = u(r, t); if (c) e[c] = e.result; return l.findNext(this, e) } } }); U.addGrammarElement("pseudoCommand", function (e, i, r) { var t = e.requireElement("primaryExpression", r); if (t.type !== "functionCall" && t.root.type !== "symbol") { e.raiseParseError("Implicit function calls must start with a simple function", r) } if (!r.matchAnyToken("to", "on", "with") && e.commandBoundary(r.currentToken())) { var n = e.requireElement("implicitMeTarget", r) } else { var n = e.requireElement("expression", r) } var o = t.root.name; var a = t.argExressions; var u = { type: "pseudoCommand", expr: t, args: [n, a], op: function (e, r, t) { var n = r[o]; if (n.hyperfunc) { t.push(e) } var a = n.apply(r, t); e.result = a; return i.findNext(u, e) }, execute: function (e) { return i.unifiedExec(this, e) } }; return u }); var l = function (e, n, r, a, t) { var i = a.type === "symbol"; var o = a.type === "attributeRef"; if (!o && !i && a.root == null) { e.raiseParseError(r, "Can only put directly into symbols, not references") } var u = null; var s = null; if (i) { } else if (o) { u = e.requireElement("implicitMeTarget", r); var l = a } else { s = a.prop ? a.prop.value : null; var l = a.attribute; u = a.root } var f = { target: a, symbolWrite: i, value: t, args: [u, t], op: function (e, r, t) { if (i) { n.setSymbol(a.name, e, a.symbolType, t) } else { n.forEach(r, function (e) { if (l) { if (t == null) { e.removeAttribute(l.name) } else { e.setAttribute(l.name, t) } } else { e[s] = t } }) } return n.findNext(this, e) } }; return f }; U.addCommand("default", function (e, t, r) { if (!r.matchToken("default")) return; var n = e.requireElement("assignableExpression", r); r.requireToken("to"); var a = e.requireElement("expression", r); var i = l(e, t, r, n, a); var o = { target: n, value: a, setter: i, args: [n], op: function (e, r) { if (r) { return t.findNext(this, e) } else { return i } } }; i.parent = o; return o }); U.addCommand("set", function (e, n, r) { if (!r.matchToken("set")) return; if (r.currentToken().type === "L_BRACE") { var t = e.requireElement("objectLiteral", r); r.requireToken("on"); var a = e.requireElement("expression", r); return { objectLiteral: t, target: a, args: [t, a], op: function (e, r, t) { j(t, r); return n.findNext(this, e) } } } try { r.pushFollow("to"); var a = e.requireElement("assignableExpression", r) } finally { r.popFollow() } r.requireToken("to"); var i = e.requireElement("expression", r); return l(e, n, r, a, i) }); U.addCommand("if", function (e, t, r) { if (!r.matchToken("if")) return; var n = e.requireElement("expression", r); r.matchToken("then"); var a = e.parseElement("commandList", r); if (r.matchToken("else")) { var i = e.parseElement("commandList", r) } if (r.hasMore()) { r.requireToken("end") } var o = { expr: n, trueBranch: a, falseBranch: i, args: [n], op: function (e, r) { if (r) { return a } else if (i) { return i } else { return t.findNext(this, e) } } }; e.setParent(a, o); e.setParent(i, o); return o }); var n = function (e, r, a, t) { var n = r.currentToken(); if (r.matchToken("for") || t) { var i = r.requireTokenType("IDENTIFIER"); var o = i.value; r.requireToken("in"); var u = e.requireElement("expression", r) } else if (r.matchToken("in")) { var o = "it"; var u = e.requireElement("expression", r) } else if (r.matchToken("while")) { var s = e.requireElement("expression", r) } else if (r.matchToken("until")) { var l = true; if (r.matchToken("event")) { var f = U.requireElement("dotOrColonPath", r, "Expected event name"); if (r.matchToken("from")) { var c = e.requireElement("expression", r) } } else { var s = e.requireElement("expression", r) } } else if (r.matchTokenType("NUMBER")) { var p = parseFloat(n.value); r.requireToken("times") } else { r.matchToken("forever"); var m = true } if (r.matchToken("index")) { var i = r.requireTokenType("IDENTIFIER"); var v = i.value } var h = e.parseElement("commandList", r); if (h && f) { var d = h; while (d.next) { d = d.next } var E = { type: "waitATick", op: function () { return new Promise(function (e) { setTimeout(function () { e(a.findNext(E)) }, 0) }) } }; d.next = E } if (r.hasMore()) { r.requireToken("end") } if (o == null) { o = "_implicit_repeat_" + n.start; var T = o } else { var T = o + "_" + n.start } var y = { identifier: o, indexIdentifier: v, slot: T, expression: u, forever: m, times: p, until: l, event: f, on: c, whileExpr: s, resolveNext: function () { return this }, loop: h, args: [s], op: function (e, r) { var t = e.meta.iterators[T]; var n = false; if (this.forever) { n = true } else if (this.until) { if (f) { n = e.meta.iterators[T].eventFired === false } else { n = r !== true } } else if (r) { n = true } else if (p) { n = t.index < this.times } else { n = t.value !== null && t.index < t.value.length } if (n) { if (t.value) { e[o] = t.value[t.index]; e.result = t.value[t.index] } else { e.result = t.index } if (v) { e[v] = t.index } t.index++; return h } else { e.meta.iterators[T] = null; return a.findNext(this.parent, e) } } }; e.setParent(h, y); var k = { name: "repeatInit", args: [u, f, c], op: function (r, e, t, n) { r.meta.iterators[T] = { index: 0, value: e, eventFired: false }; if (f) { var a = n || r.me; a.addEventListener(t, function (e) { r.meta.iterators[T].eventFired = true }, { once: true }) } return y }, execute: function (e) { return a.unifiedExec(this, e) } }; e.setParent(y, k); return k }; U.addCommand("repeat", function (e, r, t) { if (t.matchToken("repeat")) { return n(e, t, r, false) } }); U.addCommand("for", function (e, r, t) { if (t.matchToken("for")) { return n(e, t, r, true) } }); U.addGrammarElement("stringLike", function (e, r, t) { return U.parseAnyOf(["string", "nakedString"], t) }); U.addCommand("append", function (e, t, r) { if (!r.matchToken("append")) return; var n = null; var a = null; var i = e.requireElement("expression", r); if (r.matchToken("to")) { n = e.requireElement("expression", r) } if (n == null) { a = "result" } else if (n.type === "symbol") { a = n.name } else if (n.type === "propertyAccess") { a = n.prop.value } else { throw "Unable to append to " + n.type } return { value: i, target: n, args: [i], op: function (e, r) { if (Array.isArray(e[a])) { e[a].push(r) } else if (e[a] instanceof Element) { if (typeof r == "string") { e[a].innerHTML += r } else { throw "Don't know how to append non-strings to an HTML Element yet." } } else { e[a] += r } return t.findNext(this, e) }, execute: function (e) { return t.unifiedExec(this, e, i, n) } } }); U.addCommand("increment", function (i, o, u) { if (!u.matchToken("increment")) return; var r; var s = i.parseElement("assignableExpression", u); if (u.matchToken("by")) { r = i.requireElement("expression", u) } return { target: s, args: [s, r], op: function (e, r, t) { r = r ? parseFloat(r) : 0; t = t ? parseFloat(t) : 1; var n = r + t; var a = l(i, o, u, s, n); e.result = n; a.parent = this; return a }, execute: function (e) { return o.unifiedExec(this, e, s, r) } } }); U.addCommand("decrement", function (i, o, u) { if (!u.matchToken("decrement")) return; var r; var s = i.parseElement("assignableExpression", u); if (u.matchToken("by")) { r = i.requireElement("expression", u) } return { target: s, args: [s, r], op: function (e, r, t) { r = r ? parseFloat(r) : 0; t = t ? parseFloat(t) : 1; var n = r - t; var a = l(i, o, u, s, n); e.result = n; a.parent = this; return a }, execute: function (e) { return o.unifiedExec(this, e, s, r) } } }); U.addCommand("fetch", function (e, n, r) { if (!r.matchToken("fetch")) return; var t = e.requireElement("stringLike", r); var a = e.parseElement("objectLiteral", r); var i = "text"; var o; if (r.matchToken("as")) { if (r.matchToken("json")) { i = "json" } else if (r.matchToken("response")) { i = "response" } else if (r.matchToken("html")) { i = "html" } else if (r.matchToken("text")) { } else { o = e.requireElement("dotOrColonPath", r).evaluate() } } var u = { url: t, argExpressions: a, args: [t, a], op: function (r, e, t) { return fetch(e, t).then(function (e) { if (i === "response") { r.result = e; return n.findNext(u, r) } if (i === "json") { return e.json().then(function (e) { r.result = e; return n.findNext(u, r) }) } return e.text().then(function (e) { if (o) e = n.convertValue(e, o); if (i === "html") e = n.convertValue(e, "Fragment"); r.result = e; return n.findNext(u, r) }) }).catch(function (e) { n.triggerEvent(r.me, "fetch:error", { reason: e }); throw e }) } }; return u }) } function e(e) { if (document.readyState !== "loading") { setTimeout(e) } else { document.addEventListener("DOMContentLoaded", e) } } function i() { var e = document.querySelector('meta[name="htmx-config"]'); if (e) { return r(e.content) } else { return null } } function o() { var e = i(); if (e) { _hyperscript.config = j(_hyperscript.config, e) } } if ("document" in G) { Promise.all(Array.from(document.querySelectorAll("script[type='text/hyperscript'][src]")).map(function (e) { return fetch(e.src).then(function (e) { return e.text() }).then(function (e) { return z.evaluate(e) }) })).then(function () { e(function () { o(); z.processNode(document.documentElement); document.addEventListener("htmx:load", function (e) { z.processNode(e.detail.elt) }) }) }) } return j(function (e, r) { return z.evaluate(e, r) }, { internals: { lexer: B, parser: U, runtime: z }, addFeature: function (e, r) { U.addFeature(e, r) }, addCommand: function (e, r) { U.addCommand(e, r) }, addLeafExpression: function (e, r) { U.addLeafExpression(e, r) }, addIndirectExpression: function (e, r) { U.addIndirectExpression(e, r) }, evaluate: function (e, r) { return z.evaluate(e, r) }, parse: function (e) { return z.parse(e) }, processNode: function (e) { z.processNode(e) }, config: { attributes: "_, script, data-script", defaultTransition: "all 500ms ease-in", disableSelector: "[disable-scripting], [data-disable-scripting]", conversions: W } }) }); (function () { function o(e, r) { for (var t in r) { if (r.hasOwnProperty(t)) { e[t] = r[t] } } return e } _hyperscript.addCommand("settle", function (e, o, r) { if (r.matchToken("settle")) { if (!e.commandBoundary(r.currentToken())) { var t = e.requireElement("expression", r) } else { var t = e.requireElement("implicitMeTarget", r) } var u = { type: "settleCmd", args: [t], op: function (e, r) { var t = null; var n = false; var a = false; var i = new Promise(function (e) { t = e }); r.addEventListener("transitionstart", function () { a = true }, { once: true }); setTimeout(function () { if (!a && !n) { t(o.findNext(u, e)) } }, 500); r.addEventListener("transitionend", function () { if (!n) { t(o.findNext(u, e)) } }, { once: true }); return i }, execute: function (e) { return o.unifiedExec(this, e) } }; return u } }); _hyperscript.addCommand("add", function (e, n, r) { if (r.matchToken("add")) { var t = e.parseElement("classRef", r); var a = null; var i = null; if (t == null) { a = e.parseElement("attributeRef", r); if (a == null) { i = e.parseElement("objectLiteral", r); if (i == null) { e.raiseParseError(r, "Expected either a class reference or attribute expression") } } } else { var o = [t]; while (t = e.parseElement("classRef", r)) { o.push(t) } } if (r.matchToken("to")) { var u = e.requireElement("expression", r) } else { var u = e.parseElement("implicitMeTarget", r) } if (o) { var s = { classRefs: o, to: u, args: [u], op: function (e, t) { n.forEach(o, function (r) { n.forEach(t, function (e) { if (e instanceof Element) e.classList.add(r.className()) }) }); return n.findNext(this, e) } } } else if (a) { var s = { type: "addCmd", attributeRef: a, to: u, args: [u], op: function (e, r, t) { n.forEach(r, function (e) { e.setAttribute(a.name, a.value) }); return n.findNext(s, e) }, execute: function (e) { return n.unifiedExec(this, e) } } } else { var s = { type: "addCmd", cssDeclaration: i, to: u, args: [u, i], op: function (e, r, t) { n.forEach(r, function (e) { for (var r in t) { if (t.hasOwnProperty(r)) { e.style.setProperty(r, t[r]) } } }); return n.findNext(s, e) }, execute: function (e) { return n.unifiedExec(this, e) } } } return s } }); _hyperscript.addCommand("remove", function (e, n, r) { if (r.matchToken("remove")) { var t = e.parseElement("classRef", r); var a = null; var i = null; if (t == null) { a = e.parseElement("attributeRef", r); if (a == null) { i = e.parseElement("expression", r); if (i == null) { e.raiseParseError(r, "Expected either a class reference, attribute expression or value expression") } } } else { var o = [t]; while (t = e.parseElement("classRef", r)) { o.push(t) } } if (r.matchToken("from")) { var u = e.requireElement("expression", r) } else { var u = e.requireElement("implicitMeTarget", r) } if (i) { var s = { elementExpr: i, from: u, args: [i], op: function (e, r) { n.forEach(r, function (e) { if (e.parentElement) { e.parentElement.removeChild(e) } }); return n.findNext(this, e) } } } else { var s = { classRefs: o, attributeRef: a, elementExpr: i, from: u, args: [u], op: function (e, t) { if (this.classRefs) { n.forEach(o, function (r) { n.forEach(t, function (e) { e.classList.remove(r.className()) }) }) } else { n.forEach(t, function (e) { e.removeAttribute(a.name) }) } return n.findNext(this, e) } } } return s } }); _hyperscript.addCommand("toggle", function (e, o, r) { if (r.matchToken("toggle")) { if (r.matchToken("between")) { var t = true; var n = e.parseElement("classRef", r); r.requireToken("and"); var a = e.requireElement("classRef", r) } else { var n = e.parseElement("classRef", r); var i = null; if (n == null) { i = e.parseElement("attributeRef", r); if (i == null) { e.raiseParseError(r, "Expected either a class reference or attribute expression") } } else { var u = [n]; while (n = e.parseElement("classRef", r)) { u.push(n) } } } if (r.matchToken("on")) { var s = e.requireElement("expression", r) } else { var s = e.requireElement("implicitMeTarget", r) } if (r.matchToken("for")) { var l = e.requireElement("timeExpression", r) } else if (r.matchToken("until")) { var f = e.requireElement("dotOrColonPath", r, "Expected event name"); if (r.matchToken("from")) { var c = e.requireElement("expression", r) } } var p = { classRef: n, classRef2: a, classRefs: u, attributeRef: i, on: s, time: l, evt: f, from: c, toggle: function (e) { if (t) { o.forEach(e, function (e) { if (e.classList.contains(n.className())) { e.classList.remove(n.className()); e.classList.add(a.className()) } else { e.classList.add(n.className()); e.classList.remove(a.className()) } }) } else if (this.classRefs) { o.forEach(this.classRefs, function (r) { o.forEach(e, function (e) { e.classList.toggle(r.className()) }) }) } else { o.forEach(e, function (e) { if (e.hasAttribute(i.name)) { e.removeAttribute(i.name) } else { e.setAttribute(i.name, i.value) } }) } }, args: [s, l, f, c], op: function (t, n, r, a, i) { if (r) { return new Promise(function (e) { p.toggle(n); setTimeout(function () { p.toggle(n); e(o.findNext(p, t)) }, r) }) } else if (a) { return new Promise(function (e) { var r = i || t.me; r.addEventListener(a, function () { p.toggle(n); e(o.findNext(p, t)) }, { once: true }); p.toggle(n) }) } else { this.toggle(n); return o.findNext(p, t) } } }; return p } }); var u = { display: function (e, r, t) { if (t) { r.style.display = t } else if (e === "hide") { r.style.display = "none" } else { r.style.display = "block" } }, visibility: function (e, r, t) { if (t) { r.style.visibility = t } else if (e === "hide") { r.style.visibility = "hidden" } else { r.style.visibility = "visible" } }, opacity: function (e, r, t) { if (t) { r.style.opacity = t } else if (e === "hide") { r.style.opacity = "0" } else { r.style.opacity = "1" } } }; var s = function (e, r, t) { var n; var a = t.currentToken(); if (a.value === "with" || e.commandBoundary(a)) { n = e.parseElement("implicitMeTarget", t) } else { n = e.parseElement("expression", t) } return n }; var l = function (e, r, t) { var n = _hyperscript.config.defaultHideShowStrategy; var a = u; if (_hyperscript.config.hideShowStrategies) { a = o(a, _hyperscript.config.hideShowStrategies) } t = t || n || "display"; var i = a[t]; if (i == null) { e.raiseParseError(r, "Unknown show/hide strategy : " + t) } return i }; _hyperscript.addCommand("hide", function (e, t, r) { if (r.matchToken("hide")) { var n = s(e, t, r); var a = null; if (r.matchToken("with")) { a = r.requireTokenType("IDENTIFIER").value } var i = l(e, r, a); return { target: n, args: [n], op: function (e, r) { t.forEach(r, function (e) { i("hide", e) }); return t.findNext(this, e) } } } }); _hyperscript.addCommand("show", function (e, t, r) { if (r.matchToken("show")) { var n = s(e, t, r); var a = null; if (r.matchToken("with")) { a = r.requireTokenType("IDENTIFIER").value } var i = null; if (r.matchOpToken(":")) { var o = r.consumeUntilWhitespace(); r.matchTokenType("WHITESPACE"); i = o.map(function (e) { return e.value }).join("") } var u = l(e, r, a); return { target: n, args: [n], op: function (e, r) { t.forEach(r, function (e) { u("show", e, i) }); return t.findNext(this, e) } } } }); _hyperscript.addCommand("trigger", function (e, n, r) { if (r.matchToken("trigger")) { var t = e.requireElement("eventName", r); var a = e.parseElement("namedArgumentList", r); var i = { eventName: t, details: a, args: [t, a], op: function (e, r, t) { n.triggerEvent(e.me, r, t ? t : {}); return n.findNext(i, e) } }; return i } }); _hyperscript.addCommand("take", function (e, a, r) { if (r.matchToken("take")) { var t = e.parseElement("classRef", r); if (r.matchToken("from")) { var n = e.requireElement("expression", r) } else { var n = t } if (r.matchToken("for")) { var i = e.requireElement("expression", r) } else { var i = e.requireElement("implicitMeTarget", r) } var o = { classRef: t, from: n, forElt: i, args: [n, i], op: function (e, r, t) { var n = this.classRef.css.substr(1); a.forEach(r, function (e) { e.classList.remove(n) }); a.forEach(t, function (e) { e.classList.add(n) }); return a.findNext(this, e) } }; return o } }); function p(e, r, t) { if (r) { var n = e[r] } else { var n = e } if (n instanceof Element || n instanceof HTMLDocument) { while (n.firstChild) n.removeChild(n.firstChild); n.append(_hyperscript.internals.runtime.convertValue(t, "Fragment")) } else { if (r) { e[r] = t } else { throw "Don't know how to put a value into " + typeof e } } } _hyperscript.addCommand("put", function (e, a, r) { if (r.matchToken("put")) { var t = e.requireElement("expression", r); var n = r.matchAnyToken("into", "before", "after"); if (n == null && r.matchToken("at")) { n = r.matchAnyToken("start", "end"); r.requireToken("of") } if (n == null) { e.raiseParseError(r, "Expected one of 'into', 'before', 'at start of', 'at end of', 'after'") } var i = e.requireElement("expression", r); var o = n.value; var u = false; var s = null; var l = null; if (i.type === "propertyAccess" && o === "into") { l = i.prop.value; s = i.root } else if (i.type === "symbol" && o === "into") { u = true; l = i.name } else if (i.type === "attributeRef" && o === "into") { var f = true; l = i.name; s = e.requireElement("implicitMeTarget", r) } else if (i.type === "attributeRefAccess" && o === "into") { var f = true; l = i.attribute.name; s = i.root } else { s = i } var c = { target: i, operation: o, symbolWrite: u, value: t, args: [s, t], op: function (e, r, t) { if (u) { p(e, l, t) } else { if (o === "into") { if (f) { a.forEach(r, function (e) { e.setAttribute(l, t) }) } else { a.forEach(r, function (e) { p(e, l, t) }) } } else { var n = o === "before" ? Element.prototype.before : o === "after" ? Element.prototype.after : o === "start" ? Element.prototype.prepend : o === "end" ? Element.prototype.append : "unreachable"; a.forEach(r, function (e) { n.call(e, t instanceof Node ? t : a.convertValue(t, "Fragment")) }) } } return a.findNext(this, e) } }; return c } }); function f(e, r, t) { if (t.matchToken("the") || t.matchToken("element") || t.matchToken("elements") || t.currentToken().type === "CLASS_REF" || t.currentToken().type === "ID_REF" || t.currentToken().op && t.currentToken().value === "<") { e.possessivesDisabled = true; try { var n = e.parseElement("expression", t) } finally { delete e.possessivesDisabled } if (t.matchOpToken("'")) { t.requireToken("s") } } else if (t.currentToken().type === "IDENTIFIER" && t.currentToken().value === "its") { var a = t.matchToken("its"); var n = { type: "pseudopossessiveIts", token: a, name: a.value, evaluate: function (e) { return r.resolveSymbol("it", e) } } } else { t.matchToken("my") || t.matchToken("me"); var n = e.parseElement("implicitMeTarget", t) } return n } _hyperscript.addCommand("transition", function (e, E, r) { if (r.matchToken("transition")) { var t = f(e, E, r); var n = []; var a = []; var i = []; var o = r.currentToken(); while (!e.commandBoundary(o) && o.value !== "over" && o.value !== "using") { n.push(e.requireElement("stringLike", r)); if (r.matchToken("from")) { a.push(e.requireElement("stringLike", r)) } else { a.push(null) } r.requireToken("to"); i.push(e.requireElement("stringLike", r)); o = r.currentToken() } if (r.matchToken("over")) { var u = e.requireElement("timeExpression", r) } else if (r.matchToken("using")) { var s = e.requireElement("expression", r) } var l = { to: i, args: [t, n, a, i, s, u], op: function (e, r, p, m, v, h, d) { var t = []; E.forEach(r, function (c) { var e = new Promise(function (i, e) { var o = c.style.transition; if (d) { c.style.transition = "all " + d + "ms ease-in" } else if (h) { c.style.transition = h } else { c.style.transition = _hyperscript.config.defaultTransition } var u = E.getInternalData(c); var r = getComputedStyle(c); var t = {}; for (var n = 0; n < r.length; n++) { var a = r[n]; var s = r[a]; t[a] = s } if (!u.initalStyles) { u.initalStyles = t } for (var n = 0; n < p.length; n++) { var l = p[n]; var f = m[n]; if (f == "computed" || f == null) { c.style[l] = t[l] } else { c.style[l] = f } } setTimeout(function () { var e = []; for (var r = 0; r < p.length; r++) { var t = p[r]; var n = v[r]; if (n == "initial") { var a = u.initalStyles[t]; c.style[t] = a } else { c.style[t] = n } } c.addEventListener("transitionend", function () { c.style.transition = o; i() }, { once: true }) }, 5) }); t.push(e) }); return Promise.all(t).then(function () { return E.findNext(l, e) }) } }; return l } }); _hyperscript.addCommand("measure", function (e, a, r) { if (!r.matchToken("measure")) return; var t = f(e, a, r); var i = []; if (!e.commandBoundary(r.currentToken())) do { i.push(r.matchTokenType("IDENTIFIER").value) } while (r.matchOpToken(",")); return { properties: i, args: [t], op: function (r, e) { if (0 in e) e = e[0]; var t = e.getBoundingClientRect(); var n = { top: e.scrollTop, left: e.scrollLeft, topMax: e.scrollTopMax, leftMax: e.scrollLeftMax, height: e.scrollHeight, width: e.scrollWidth }; r.result = { x: t.x, y: t.y, left: t.left, top: t.top, right: t.right, bottom: t.bottom, width: t.width, height: t.height, bounds: t, scrollLeft: n.left, scrollTop: n.top, scrollLeftMax: n.leftMax, scrollTopMax: n.topMax, scrollWidth: n.width, scrollHeight: n.height, scroll: n }; a.forEach(i, function (e) { if (e in r.result) r[e] = r.result[e]; else throw "No such measurement as " + e }); return a.findNext(this, r) } } }); _hyperscript.addLeafExpression("closestExpr", function (e, r, t) { if (t.matchToken("closest")) { if (t.matchToken("parent")) { var n = true } var a = null; if (t.currentToken().type === "ATTRIBUTE_REF") { var i = e.parseElement("attributeRefAccess", t, null); a = "[" + i.attribute.name + "]" } if (a == null) { var o = e.parseElement("expression", t); if (o.css == null) { e.raiseParseError(t, "Expected a CSS expression") } else { a = o.css } } if (t.matchToken("to")) { var u = e.parseElement("expression", t) } else { var u = e.parseElement("implicitMeTarget", t) } var s = { type: "closestExpr", parentSearch: n, expr: o, css: a, to: u, args: [u], op: function (e, r) { if (r == null || !(r instanceof Element)) { return null } else { if (n) { var t = r.parentElement ? r.parentElement.closest(a) : null } else { var t = r.closest(a) } return t } }, evaluate: function (e) { return r.unifiedEval(this, e) } }; if (i) { i.root = s; i.args = [s]; return i } else { return s } } }); _hyperscript.addCommand("go", function (e, t, r) { if (r.matchToken("go")) { if (r.matchToken("back")) { var n = true } else { r.matchToken("to"); if (r.matchToken("url")) { var a = e.requireElement("stringLike", r); var i = true; if (r.matchToken("in")) { r.requireToken("new"); r.requireToken("window"); var o = true } } else { r.matchToken("the"); var u = r.matchAnyToken("top", "bottom", "middle"); var s = r.matchAnyToken("left", "center", "right"); if (u || s) { r.requireToken("of") } var a = e.requireElement("expression", r); var l = r.matchAnyToken("smoothly", "instantly"); var f = {}; if (u) { if (u.value === "top") { f.block = "start" } else if (u.value === "bottom") { f.block = "end" } else if (u.value === "middle") { f.block = "center" } } if (s) { if (s.value === "left") { f.inline = "start" } else if (s.value === "center") { f.inline = "center" } else if (s.value === "right") { f.inline = "end" } } if (l) { if (l.value === "smoothly") { f.behavior = "smooth" } else if (l.value === "instantly") { f.behavior = "instant" } } } } var c = { target: a, args: [a], op: function (e, r) { if (n) { window.history.back() } else if (i) { if (r) { if (r.indexOf("#") === 0 && !o) { window.location.href = r } else { window.open(r, o ? "_blank" : null) } } } else { t.forEach(r, function (e) { e.scrollIntoView(f) }) } return t.findNext(c) } }; return c } }); _hyperscript.config.conversions["Values"] = function (e) { var n = {}; var a = _hyperscript.internals.runtime.forEach; a(e, function (e) { var r = o(e); if (r !== undefined) { n[r.name] = r.value; return } if (e.querySelectorAll != undefined) { var t = e.querySelectorAll("input,select,textarea"); a(t, i) } }); return n; function i(e) { var r = o(e); if (r == undefined) { return } if (n[r.name] == undefined) { n[r.name] = r.value; return } if (Array.isArray(n[r.name]) && Array.isArray(r.value)) { n[r.name] = [].concat(n[r.name], r.value); return } } function o(e) { try { var r = { name: e.name, value: e.value }; if (r.name == undefined || r.value == undefined) { return undefined } if (e.type == "radio" && e.checked == false) { return undefined } if (e.type == "checkbox") { if (e.checked == false) { r.value = undefined } else if (typeof r.value === "string") { r.value = [r.value] } } if (e.type == "select-multiple") { var t = e.querySelectorAll("option[selected]"); r.value = []; for (var n = 0; n < t.length; n++) { r.value.push(t[n].value) } } return r } catch (e) { return undefined } } }; _hyperscript.config.conversions["HTML"] = function (e) { var a = function (e) { if (e instanceof Array) { return e.map(function (e) { return a(e) }).join("") } if (e instanceof HTMLElement) { return e.outerHTML } if (e instanceof NodeList) { var r = ""; for (var t = 0; t < e.length; t++) { var n = e[t]; if (n instanceof HTMLElement) { r += n.outerHTML } } return r } if (e.toString) { return e.toString() } return "" }; return a(e) }; _hyperscript.config.conversions["Fragment"] = function (e) { var t = document.createDocumentFragment(); _hyperscript.internals.runtime.forEach(e, function (e) { if (e instanceof Node) t.append(e); else { var r = document.createElement("template"); r.innerHTML = e; t.append(r.content) } }); return t } })();